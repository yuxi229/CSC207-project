Index: src/main/use_case/navigation/GraphPathFinder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package use_case.navigation;\n\nimport java.util.List;\n\nimport entity.*;\n\nimport org.jgrapht.GraphPath;\nimport org.jgrapht.graph.DefaultWeightedEdge;\nimport org.jgrapht.graph.SimpleWeightedGraph;\nimport org.jgrapht.alg.shortestpath.DijkstraShortestPath;\nimport use_case.LocationDataAccessInterface;\n\npublic class GraphPathFinder implements PathFinder {\n    private SimpleWeightedGraph<MapLocation, DefaultWeightedEdge> map\n            = new SimpleWeightedGraph<>(DefaultWeightedEdge.class);\n    private LocationDataAccessInterface database;\n    private static final double DEFAULT_WEIGHT = 1.0;\n\n    /**\n     * Default constructor. Initializes the pathfinder with no data.\n     */\n    public GraphPathFinder() {\n    }\n\n    /**\n     * Constructor that initializes the pathfinder with the given data.\n     * @param locationDAO the data access object to use\n     */\n    public GraphPathFinder(LocationDataAccessInterface locationDAO) {\n        this.database = locationDAO;\n        loadData(database);\n    }\n\n    /**\n     * Initializes the pathfinder with the given data.\n     * @param locationDAO the data access object to use\n     */\n    @Override\n    public void loadData(LocationDataAccessInterface locationDAO) {\n        database = locationDAO;\n        List<Floor> floors = database.getFloors();\n        for (Floor floor: floors) {\n            buildFloor(floor);\n        }\n        linkFloors();\n    }\n\n    /**\n     * Go through all the locations on the floor and link them together.\n     * @param floor the floor to build the graph for\n     */\n    private void buildFloor(Floor floor) {\n        // Loop through all the locations on the floor\n        for (Location location1 : floor.getLocationsList()) {\n            MapLocation mapLocation1 = database.getMapLocation(location1.getId(), floor.getFloorId());\n            // Link the location to all the locations it is connected to\n            for (Location location2 : location1.getConnected()) {\n                MapLocation mapLocation2 = database.getMapLocation(location2.getId(), floor.getFloorId());\n                linkLocations(mapLocation1, mapLocation2, calculateWeight(location1, location2));\n            }\n        }\n    }\n\n    /**\n     * Go through all the locations that span multiple floors and link them together.\n     */\n    private void linkFloors() {\n        for (Location location : database.getLocations()) {\n            List<Floor> floorsConnected = location.getFloors();\n            // If the location is on multiple floors, link its map locations on the different floors\n            if (floorsConnected.size() > 1) {\n                int curIDX = 0;\n                while (curIDX < floorsConnected.size() - 1) {\n                    Floor floor1 = floorsConnected.get(curIDX);\n                    Floor floor2 = floorsConnected.get(curIDX + 1);\n                    MapLocation mapLocation1 = database.getMapLocation(location.getId(), floor1.getFloorId());\n                    MapLocation mapLocation2 = database.getMapLocation(location.getId(), floor2.getFloorId());\n                    linkLocations(mapLocation1, mapLocation2, calculateWeight(location, location));\n                    curIDX++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Links two map locations together with the given weight.\n     */\n    private void linkLocations(MapLocation location1, MapLocation location2, Double weight) {\n        // No duplicate vertices will be added because the vertices are stored in a set\n        if (!map.containsVertex(location1)){\n            map.addVertex(location1);\n        } else if (!map.containsVertex(location2)){\n            map.addVertex(location2);\n        }\n        DefaultWeightedEdge edge = map.addEdge(location1, location2);\n        map.setEdgeWeight(edge, weight);\n    }\n\n    /**\n     * Calculates the weight between two locations.\n     */\n    private double calculateWeight(Location location1, Location location2) {\n        //TODO: Decide on weight strategy in meeting\n        return DEFAULT_WEIGHT;\n    }\n\n    private MapLocation roomCodeToMapLocation(String roomCode) {\n        Room room = database.getRoom(roomCode);\n        String floorID = room.getFloors().get(0).getFloorId(); //Pick the first floor the room is on\n        return database.getMapLocation(room.getId(), floorID);\n    }\n\n    /**\n     * Returns the path from the start room to the end room as a list of ids.\n     * @param startRoomCode valid room code for starting room\n     * @param endRoomCode valid room code for ending room\n     * @return A list of MapLocation objects representing the path.\n     */\n    @Override\n    public List<MapLocation> getPath(String startRoomCode, String endRoomCode) {\n        // Use Dijkstra's algorithm to find the shortest path. Change algorithm if needed.\n        DijkstraShortestPath<MapLocation, DefaultWeightedEdge> dijkstraAlg = new DijkstraShortestPath<>(map);\n        GraphPath<MapLocation, DefaultWeightedEdge> route =\n                dijkstraAlg.getPath(roomCodeToMapLocation(startRoomCode), roomCodeToMapLocation(endRoomCode));\n        return route.getVertexList();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/use_case/navigation/GraphPathFinder.java b/src/main/use_case/navigation/GraphPathFinder.java
--- a/src/main/use_case/navigation/GraphPathFinder.java	(revision 271797a6a895721bf783d2066a8bf4b228f321f4)
+++ b/src/main/use_case/navigation/GraphPathFinder.java	(date 1732597787161)
@@ -54,7 +54,7 @@
         for (Location location1 : floor.getLocationsList()) {
             MapLocation mapLocation1 = database.getMapLocation(location1.getId(), floor.getFloorId());
             // Link the location to all the locations it is connected to
-            for (Location location2 : location1.getConnected()) {
+            for (Location location2 : location1.getConnectedLocations()) {
                 MapLocation mapLocation2 = database.getMapLocation(location2.getId(), floor.getFloorId());
                 linkLocations(mapLocation1, mapLocation2, calculateWeight(location1, location2));
             }
Index: src/main/data_access/DBRoomDataAccessObject.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package data_access;\n\nimport entity.Room;\nimport entity.RoomFactory;\nimport use_case.LocationDataAccessInterface;\n\n/**\n * The DAO for room data.\n */\npublic class DBRoomDataAccessObject implements LocationDataAccessInterface {\n    private static final int SUCCESS_CODE = 200;\n    private static final String CONTENT_TYPE_LABEL = \"Content-Type\";\n    private static final String CONTENT_TYPE_JSON = \"application/json\";\n    private static final String STATUS_CODE_LABEL = \"status_code\";\n    private static final String ROOMCODE = \"roomcode\";\n    private static final String MESSAGE = \"message\";\n    private final RoomFactory roomFactory;\n\n    public DBRoomDataAccessObject(RoomFactory roomFactory) {\n        this.roomFactory = roomFactory;\n    }\n\n    @Override\n    public boolean existsByRoomCode(String roomCode) {\n        return false;\n    }\n\n    @Override\n    public Room get(String roomCode) {\n        return null;\n    }\n}\n\n//@Override\n//public boolean existsByRoomCode(String roomCode) {\n//    final OkHttpClient client = new OkHttpClient().newBuilder()\n//            .build();\n//    final Request request = new Request.Builder()\n//            .url(String.format(\"http://vm003.teach.cs.toronto.edu:20112/checkIfUserExists?username=%s\", username))\n//            .addHeader(CONTENT_TYPE_LABEL, CONTENT_TYPE_JSON)\n//            .build();\n//    try {\n//        final Response response = client.newCall(request).execute();\n//\n//        final JSONObject responseBody = new JSONObject(response.body().string());\n//\n//        return responseBody.getInt(STATUS_CODE_LABEL) == SUCCESS_CODE;\n//    }\n//    catch (IOException | JSONException ex) {\n//        throw new RuntimeException(ex);\n//    }\n//}\n//\n//}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/data_access/DBRoomDataAccessObject.java b/src/main/data_access/DBRoomDataAccessObject.java
--- a/src/main/data_access/DBRoomDataAccessObject.java	(revision 271797a6a895721bf783d2066a8bf4b228f321f4)
+++ b/src/main/data_access/DBRoomDataAccessObject.java	(date 1732596899547)
@@ -1,8 +1,10 @@
 package data_access;
 
-import entity.Room;
-import entity.RoomFactory;
+import entity.*;
 import use_case.LocationDataAccessInterface;
+import use_case.navigation.MapLocation;
+
+import java.util.List;
 
 /**
  * The DAO for room data.
@@ -20,13 +22,61 @@
         this.roomFactory = roomFactory;
     }
 
+    public boolean existsByRoomCode(String roomCode) {
+        return false;
+    }
+
+    public Room get(String roomCode) {
+        return null;
+    }
+
     @Override
-    public boolean existsByRoomCode(String roomCode) {
+    public boolean roomExists(String roomCode) {
+        return false;
+    }
+
+    @Override
+    public boolean idExists(String id) {
         return false;
     }
 
     @Override
-    public Room get(String roomCode) {
+    public Location getLocation(String id) {
+        return null;
+    }
+
+    @Override
+    public Room getRoom(String roomCode) {
+        return null;
+    }
+
+    @Override
+    public Floor getFloor(String id) {
+        return null;
+    }
+
+    @Override
+    public Stairs getStair(String id) {
+        return null;
+    }
+
+    @Override
+    public Corridor getCorridor(String id) {
+        return null;
+    }
+
+    @Override
+    public List<Floor> getFloors() {
+        return null;
+    }
+
+    @Override
+    public List<Location> getLocations() {
+        return null;
+    }
+
+    @Override
+    public MapLocation getMapLocation(String id, String floorID) {
         return null;
     }
 }
Index: src/test/navigation/NavigationInteractorTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package use_case.navigation;\n\nimport data_access.InMemoryRoomDataAccessObject;\nimport use_case.LocationDataAccessInterface;\nimport entity.Room;\nimport entity.RoomFactory;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NavigationInteractorTest {\n    @Test\n    void successTest() {\n        NavigationInputData inputData = new NavigationInputData(\"1100\",  \"1130\");\n        LocationDataAccessInterface roomRepository = new InMemoryRoomDataAccessObject();\n\n        // For the success test, we need to add room \"1100\" to the data access repository before we input rooms.\n        RoomFactory factory = new RoomFactory();\n        Room room = factory.create(\"1100\");\n        roomRepository.save(room);\n\n        // This creates a successPresenter that tests whether the test case is as we expect.\n        NavigationOutputBoundary successPresenter = new NavigationOutputBoundary() {\n            @Override\n            public void prepareSuccessView(NavigationOutputData user) {\n                assertEquals(\"1100\", room.getRoomCode());\n            }\n\n            @Override\n            public void prepareFailView(String error) {\n                fail(\"Use case failure is unexpected.\");\n            }\n        };\n\n        NavigationInputBoundary interactor = new NavigationInteractor(roomRepository, successPresenter);\n        interactor.execute(inputData);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/navigation/NavigationInteractorTest.java b/src/test/navigation/NavigationInteractorTest.java
--- a/src/test/navigation/NavigationInteractorTest.java	(revision 271797a6a895721bf783d2066a8bf4b228f321f4)
+++ b/src/test/navigation/NavigationInteractorTest.java	(date 1732596899548)
@@ -1,6 +1,5 @@
 package use_case.navigation;
 
-import data_access.InMemoryRoomDataAccessObject;
 import use_case.LocationDataAccessInterface;
 import entity.Room;
 import entity.RoomFactory;
@@ -12,12 +11,12 @@
     @Test
     void successTest() {
         NavigationInputData inputData = new NavigationInputData("1100",  "1130");
-        LocationDataAccessInterface roomRepository = new InMemoryRoomDataAccessObject();
+//        LocationDataAccessInterface roomRepository = new InMemoryRoomDataAccessObject();
 
         // For the success test, we need to add room "1100" to the data access repository before we input rooms.
         RoomFactory factory = new RoomFactory();
         Room room = factory.create("1100");
-        roomRepository.save(room);
+//        roomRepository.save(room);
 
         // This creates a successPresenter that tests whether the test case is as we expect.
         NavigationOutputBoundary successPresenter = new NavigationOutputBoundary() {
@@ -32,8 +31,8 @@
             }
         };
 
-        NavigationInputBoundary interactor = new NavigationInteractor(roomRepository, successPresenter);
-        interactor.execute(inputData);
+//        NavigationInputBoundary interactor = new NavigationInteractor(roomRepository, successPresenter);
+//        interactor.execute(inputData);
     }
 
 }
Index: src/main/entity/Floor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package entity;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A floor implementation that inherits Location.\n */\n\npublic class Floor {\n    private String floorID;\n    private ArrayList<Room> roomsList = new ArrayList<>();\n    private ArrayList<Location> locationsList = new ArrayList<>();\n    private ArrayList<Stairs> stairsList = new ArrayList<>();\n    private ArrayList<Corridor> corridorsList = new ArrayList<>();\n\n    Floor(String id, ArrayList<Room> roomsList, ArrayList<Stairs> stairsList,\n          ArrayList<Corridor> corridorsList) {\n        super(id);\n        this.roomsList = roomsList;\n        this.stairsList = stairsList;\n        this.corridorsList = corridorsList;\n    }\n\n    public String getFloorId() {\n        return floorID;\n    }\n\n    /**\n     * Get a list of all rooms on the floor.\n     */\n    public List<Room> getRoomsList() {\n        return roomsList;\n    }\n\n    /**\n     * Get a list of all locations on the floor.\n     */\n    public List<Location> getLocationsList() {\n        return locationsList;\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/entity/Floor.java b/src/main/entity/Floor.java
--- a/src/main/entity/Floor.java	(revision 271797a6a895721bf783d2066a8bf4b228f321f4)
+++ b/src/main/entity/Floor.java	(date 1732596938122)
@@ -16,7 +16,7 @@
 
     Floor(String id, ArrayList<Room> roomsList, ArrayList<Stairs> stairsList,
           ArrayList<Corridor> corridorsList) {
-        super(id);
+        super();
         this.roomsList = roomsList;
         this.stairsList = stairsList;
         this.corridorsList = corridorsList;
Index: src/main/data_access/InMemoryLocationDAO.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package data_access;\n\nimport java.util.HashMap;\nimport java.util.List;\n\nimport entity.*;\nimport use_case.LocationDataAccessInterface;\nimport use_case.navigation.MapLocation;\n\n/**\n * In-memory implementation of the DAO for storing navigation data. This implementation does\n * NOT persist data between runs of the program.\n */\npublic class InMemoryLocationDAO implements LocationDataAccessInterface {\n    private final HashMap<String, Location> locationMap = new HashMap<>();\n    private final HashMap<String, Room> roomCodeToRoom = new HashMap<>();\n    private final HashMap<String, Floor> floorIdToFloor = new HashMap<>();\n    private final HashMap<String, HashMap<String, MapLocation>> mapLocationLookup = new HashMap<>();\n\n    public InMemoryLocationDAO() {\n    }\n\n    public InMemoryLocationDAO(List<Location> locations, List<MapLocation> mapLocations) {\n        loadLocations(locations);\n        loadMapLocations(mapLocations);\n    }\n\n    private void loadLocations(List<Location> locations) {\n        for (Location location : locations) {\n            // Add location to locationMap\n            locationMap.put(location.getId(), location);\n\n            // Add rooms to roomCodeToRoom\n            if (location instanceof Room) {\n                roomCodeToRoom.put(((Room) location).getRoomCode(), (Room) location);\n            }\n            // Add floors to floorIdToFloor\n            for (Floor floor : location.getFloors()) {\n                if (!floorIdToFloor.containsKey(floor.getFloorId())) {\n                    floorIdToFloor.put(floor.getFloorId(), floor);\n                }\n            }\n        }\n    }\n\n    private void loadMapLocations(List<MapLocation> mapLocations) {\n        for (MapLocation mapLocation : mapLocations) {\n            if (!mapLocationLookup.containsKey(mapLocation.getLocationID())) {\n                mapLocationLookup.put(mapLocation.getLocationID(), new HashMap<>());\n            }\n            mapLocationLookup.get(mapLocation.getLocationID()).put(mapLocation.getFloorID(), mapLocation);\n        }\n    }\n\n    @Override\n    public boolean roomExists(String roomCode) {\n        return roomCodeToRoom.containsKey(roomCode);\n    }\n\n    @Override\n    public boolean idExists(String id) {\n        return locationMap.containsKey(id);\n    }\n\n    @Override\n    public Location getLocation(String id) {\n        return locationMap.get(id);\n    }\n\n    @Override\n    public Room getRoom(String roomCode) {\n        return roomCodeToRoom.get(roomCode);\n    }\n\n    @Override\n    public Floor getFloor(String id) {\n        return floorIdToFloor.get(id);\n    }\n\n    @Override\n    public Stairs getStair(String id) {\n        if (locationMap.containsKey(id) && locationMap.get(id) instanceof Stairs) {\n            return (Stairs) locationMap.get(id);\n        }\n        return null;\n    }\n\n    @Override\n    public Corridor getCorridor(String id) {\n        if (locationMap.containsKey(id) && locationMap.get(id) instanceof Corridor) {\n            return (Corridor) locationMap.get(id);\n        }\n        return null;\n    }\n\n    @Override\n    public List<Floor> getFloors() {\n        return List.copyOf(floorIdToFloor.values());\n    }\n\n    @Override\n    public List<Location> getLocations() {\n        return List.copyOf(locationMap.values());\n    }\n\n    @Override\n    public MapLocation getMapLocation(String id, String floorID) {\n        return mapLocationLookup.get(id).get(floorID);\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/data_access/InMemoryLocationDAO.java b/src/main/data_access/InMemoryLocationDAO.java
--- a/src/main/data_access/InMemoryLocationDAO.java	(revision 271797a6a895721bf783d2066a8bf4b228f321f4)
+++ b/src/main/data_access/InMemoryLocationDAO.java	(date 1732596899547)
@@ -28,7 +28,7 @@
     private void loadLocations(List<Location> locations) {
         for (Location location : locations) {
             // Add location to locationMap
-            locationMap.put(location.getId(), location);
+//            locationMap.put(location.getId(newName), location);
 
             // Add rooms to roomCodeToRoom
             if (location instanceof Room) {
